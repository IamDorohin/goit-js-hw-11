// Порядок створення функції нескінченого скрола(infinite scroll) галереї зображень.

// 1. Після списка <ul>, що має прокручуватись, помістити пустий <div>,
// пересікання яким меж viewport'а буде відслідковуватись для завантаження наступних зображень.
// <div class='container'></div>

// 2.    Викликати конструктор IntersectionObserver, в який помістити:
// 2.1.  callback-функцію, що буде містити функціонал,
//       виконання якого здійснюється в момент перетинання пустим контейнером області viewport'a;
// 2.2.  опції, що можуть бути застосовані у разі необхідності (зміна root-margin тощо).
//       За замовчуванням в опції краще внести rootMargin для уникнення докручування
//       користувачем до пустого контейнера. Наприклад 200px.
// const observer = new IntersectionObserver(onEntry, options);
// const options =  {
//     rootMargin: '200px',
// };

// 3. Всередині callback-функції ініціювати перевірку факту перетинання області viewport'a елементом,
// що відслідковується, та внести всередину неї функції з фетча нових даних з бекенда.
// entries - дефолтний список об’єктів, за якими відбуваєтсья спостереження.

// При доданні слухача на факт перетинання пустим <div> області viewport'a з моменту відкриття сторінки
// за замовчуванням спрацює функція фетча даних, але без введених користувачем у поле пошуку запитів.
// В результаті повернеться помилка запиту. Усунути можливість фетча даних до першого запиту користувача
// можна за допомогою додавання в правило відслудковування факту перетинання пустим <div> області viewport'a
// також правила наявності значення query у полі пошукового запиту. Тобто ми виконуємо фетч даних тальки за умови
// якщо пустий <div> перетнув область viewport'a та query поля пошукового запиту не є пустим рядком.
// const onEntry = entries => {
//     entries.forEach(entry => {
//         if(entry.isIntersecting && функція фетча.query !== '') {
               // функції з фетча даних;
//         }
//     })
// }
// 3. Повісити на пустий контейнер відстеження події перетинання ним області viewport'a.
// observer.observe(emptyContainerEL);


// const onEntry = entries => {
//     entries.forEach(entry => {
//         if(entry.isIntersecting) {
//         }
//     })
// }

// const options =  {
//     rootMargin: '200px',
// };

// const observer = new IntersectionObserver(onEntry, options);

// const emptyContainerEL = document.querySelector('.container');
// observer.observe(emptyContainerEL);